package pego

import (
	"fmt"
	"strconv"
	"strings"
)

const PROBLEM_8_INPUT = `731671765313306249192251196744265747423553491949349698352031277450632623
9578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386
3050715693290963295227443043557668966489504452445231617318564030987111217223831136222989342338030
8135336276614282806444486645238749303589072962904915604407723907138105158593079608667017242712188
3998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771
1670556013604839586446706324415722155397536978179778461740649551492908625693219784686224828397224
1375657056057490261407972968652414535100474821663704844031998900088952434506585412275886668811642
7171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422
4219022671055626321111109370544217506941658960408071984038509624554443629812309878799272442849091
8884580156166097919133875499200524063689912560717606058861164671094050775410022569831552000559357
2972571636269561882670428252483600823257530420752963450`

func SolveProblem8() int {
	return findLargestProduct(strings.TrimSpace(PROBLEM_8_INPUT), 13)
}

func findLargestProduct(input string, seqLength int) int {
	inputLength := len(input)
	maxIndex := inputLength - 1
	maxProduct := 0

	for i := 0; i < inputLength; i++ {
		var upperIndex = (i + seqLength)
		if upperIndex > maxIndex {
			continue
		}
		sequence := input[i:upperIndex]
		if strings.Contains(sequence, "0") {
			continue
		}
		product := 1

		for _, element := range sequence {
			digit, _ := strconv.Atoi(string(element))
			fmt.Print(digit)
			product = (product * digit)
		}
		fmt.Printf(", product=%d\n", product)

		if product > maxProduct {
			maxProduct = product
		}
	}

	return maxProduct
}
